---
title: Making a blog using Eleventy
tags: ["11ty", "js", "webdev"]
date: 2025-08-26
note: "DISCLAIMER: This blog is still a work in progress, so not everything here is final."
---

I've been reading a lot of blogs about many different topics lately and I decided I might try making my own, so I decided to look into what kind of tools one might use.
I quickly stumbled upon [Eleventy](https://11ty.dev/) and it seemed to fit my needs nicely.
I'm not very experienced with web development and my JavaScript knowledge is very limited, so there was a bit of a learning curve there.
Luckily, Eleventy doesn't require you to know all that much JavaScript. You only really need to know HTML and CSS... which I didn't. Oh boy.

I started out by doing some of the [tutorials on MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Getting_started), but I got bored pretty quicky.
So I decided instead to look at the source for blogs I had already been reading and study them.
This was very informative! I think I learned a lot more that way than through tutorials.
Feel free to look through the source of this website using your browser's inspect tool.
It's far from the best code you'll see -- especially since part of it is generated by Eleventy -- but I think I did a pretty good job.

Once I had made some (pretty ugly) pages with basic HTML and CSS, I finally started working with Eleventy.
This required me to install node, which I did pretty easily with pacman:

```sh
$ sudo pacman -S nodejs
```

Then all I had to do was initialize an npm project and install Eleventy:

```sh
$ npm init -y
$ npm install @11ty/eleventy
```

I also prefer ESM over CommonJS, so I had to configure the package for it as well: 

```sh
$ npm pkg set type="module"
```

And I was all set to begin working on the site!
Eleventy uses a JavaScript file for configuration.
This is part of why it's so powerful: it is extremely extensible.
My first config was pretty standard as all I wanted at that point was for my source files to be in a `src` folder:

```js
export default function(eleventyConfig) {

    // config here !

    return {
        dir: {
            input: "src",
        },
    };
};
```

I could then begin designing my website.
I started by adding an index.html to my src folder.
I didn't want to touch any of the templating just yet, all I wanted was a basic functionless site to get things going.

However, when I tried to add styling, it seemed that my style.css file was not being found by the browser.
After quite a bit of head scratching, I finally gave up trying to figure it out on my own and turned to the internets.
Turns out I needed to add this line to my config for it to work:

```js
eleventyConfig.addPassthroughCopy("./src/style.css");
```

Because apparently, Eleventy will manage template files in your source folder but completely ignore any other file?
I'm not entirely sure why Eleventy can't just copy the CSS file for me, but I'm sure there's a good reason somewhere out there.

Well, at least styling works now. But, uh oh, Eleventy's file watching doesn't. Great.
For a while I stopped using the file watching and ran the generator manually because I couldn't figure out why it suddenly stopped working.
But then someone pointed out I was probably just an idiot, so I once again turned to the ever-wise internets for an answer.
I searched around for a bit and eventually I found a solution that worked.
Turns out this is an active issue with Eleventy, and you need to manually specify that you want to watch for changes in the file:

```js
eleventyConfig.addWatchTarget("./src/style.css");
```

That's pretty annoying, but since it's an open issue I'll let it slide. Maybe we'll see this fixed in Eleventy 4.0, who knows.
But it works now and that's all that matters: I can keep working on my website.
At this point I needed to add some more pages, so I decided to finally use the one feature I needed Eleventy for: templating.^[Well, that and the markdown rendering, but to me the templating is cooler.]

To use the templating feature I needed to pick a template language.
Eleventy supports a large number of languages, which was a bit daunting at first.
Remember: I have 0 web dev experience.
I didn't know a single one of these templating languages^[Except the basic HTML and Markdown.], so I had no idea what the ergonomics of these languages looked like.
The Eleventy guide was of no help either. Every example has buttons to swap between the different templating languages, which is very nice when you know which one to use but not very helpful when you're completely clueless.

Eleventy supports different templating languages on the same project so it didn't really matter which one I picked.
Most of the supported templates require installing an Eleventy plugin, so realistically you only get two options: [Liquid](https://liquidjs.com/index.html) and [Nunjucks](https://mozilla.github.io/nunjucks/).
The general concensus in the community seems to be that Nunjucks is the way to go, so that's what I went with.

To get templates going, I added an `_includes` folder to my `src` folder and created a `base.njk` file to serve as the base template for all my website's file.

{% raw %}
```jinja
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% if title %} {{ title }} - loudbytes{% else %}loudbytes{% endif %}</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" type="text/css" media="all" href="/style.css">
  </head>
  <body>
    <header>
      <div class="container">
        <div class="home-link-div">
          <h1><a href="/">loudbytes</a></h1>
        </div>
        <div class="nav-div">
          <nav class="main-nav" aria-label="Main navigation">
            <a href="/about/">about</a>
            <a href="/blog/">blog</a>
            <a href="/tags/">tags</a>
            <a href="/feed.xml">rss</a>
          </nav>
        </div>
      </div>
    </header>

    <main>
      {{ content | safe }}
    </main>

    <footer>&copy; Antoine Gallien 2025</footer>
  </body>
</html>
```
{% endraw %}

This is the basis for all pages on this website (except the rss feed).
Next, I had to provide it with some content, so I went to my [favorite ipsum generator](http://www.catipsum.com/) and generated some testing blog posts.
I created a simple post template in nunjucks called `post.njk` and created some markdown blog posts in a `blog` folder.
In the blog folder I also added a json file called `blog.json`.
Eleventy uses JSON files to grab additional data about neighboring files, which is very useful to avoid boilerplate.

The JSON file specifies the base layout and the post tag, which is shared between all blog posts:

```json
{
  "layout": "post.njk",
  "tags": "post"
}
```

Oh, I haven't talked about tags yet. Tags are an extremely useful feature of Eleventy that allow you to group pages and access them easily through the collections API.
By tagging all blog posts with the `post` tag, I can then easily get all blog posts by accessing `collections.post`:

{% raw %}
```jinja
<article>
  <h1>Blog</h1>

  <ul class="post-list">
  {% for post in collections.post | reverse %}
    {% include "post-preview.njk" %}
  {% endfor %}
  </ul>

</article>
```
{% endraw %}

Each post has a header where I define its title, date and additional tags.
By default, tags defined in the file header and added onto the existing list of tags, so you don't have to worry about overwriting them.^[If you do want to overwrite the tags however, Eleventy's got you covered! You simply need to add `override:` before the tags like so: `override:tags: ["tagA", "tagB"]`]
For example, this is what this post's header looks like:

```yaml
---
title: Making a blog using Eleventy
tags: ["11ty", "js", "webdev"]
date: 2025-08-26
---
```

Technically you don't have to specify the date because Eleventy will use the file's creation date by default. I like specifying it however because I may not upload the post on the same day I started writing it. This also ensures the date remains the same no matter what happens to the original file.

You can also specify custom entries for the header, which is really useful.
If I wanted to, say, add a thumbnail to my blog post, I could support that by just adding the thumbnail URI to the header and then looking it up in my template code.
You don't have to define it in the config file beforehand or anything, it just works.

Eleventy also supports easy pagination. I use this feature for my blog index. You simply need to specify the following in the header:

```yaml
---
layout: base.njk
eleventyImport:
    collections: ["posts"]
pagination:
  data: collections.post
  size: 10
  alias: posts
  reverse: true
---
```

The `eleventyImport` section is because otherwise Eleventy complains about collections.post not being built yet, so you need to specify you need it before building the page.
We give an alias to the posts, here literally `posts`. This is an array of size `size` or less, containing your posts for the page. `reverse` specifies I want it in reverse order (newest first).
With some simple template code to get basic navigation working, this is what the blog page template looks like:

{% raw %}
```jinja
---
layout: base.njk
eleventyImport:
    collections: ["posts"]
pagination:
  data: collections.post
  size: 10
  alias: posts
  reverse: true
---

<article>
  <h1>Blog</h1>
  <ul class="post-list">
  {% for post in posts | reverse %}
  {% include "post-preview.njk" %}
  {% endfor %}
  </ul>
  <nav class="page-nav">
    <a class="previous-page {{"hidden" if pagination.href.previous == nil}}" href="{{pagination.href.previous}}">&lt;&lt; previous</a>
    <p class="page-nav-pages">
    {%- for pageEntry in pagination.pages %}
    <a href="{{ pagination.hrefs[ loop.index0 ] }}"{% if page.url == pagination.hrefs[ loop.index0 ] %} id="current-page" aria-current="page"{% endif %}>{{ loop.index }}</a>
    {%- endfor %}
    </p>
    <a class="next-page {{"hidden" if pagination.href.next == nil}}" href="{{pagination.href.next}}">next &gt;&gt;</a>
  </nav>
</article>
```
{% endraw %}

For the tags page I needed a bit of setup.
First, I implement a custom collection called "tags", containing all tags except the post tag.

```js
eleventyConfig.addCollection("tags", (collectionApi) => {
  let tags = new Set();
  let posts = collectionApi.getFilteredByTag("post");
  posts.forEach(p => {
    p.data.tags.forEach(t => {
      if (t != "post") {
        tags.add(t);
      }
    });
  });
  return Array.from(tags);
});
```

Then I can just loop through the tags collection and display the tags in a list:

{% raw %}
```jinja
---
layout: base.njk
---

<article>
  <h1>All Tags</h1>
  <ul class="tag-list">
  {% for tag in collections.tags %}
    {% set posts = collections.post | filterByTag(tag) %}
    <li>
      <a class="underline" href="/tags/{{ tag | slugify }}/index.html">{{tag}}</a>
      ({{posts | length}})
    </li>
  {% endfor %}
  </ul>
</article>
```
{% endraw %}

I use my first instance of a custom shortcode here.
Custom shortcodes are an Eleventy feature that allow you to add custom functions to your templates.

The shortcode in question is `filterByTag`.
Here's how it looks like in my JS config:

```js
eleventyConfig.addFilter("filterByTag", (posts, tag) => {
  tag = tag.toLowerCase();
  let result = posts.filter(p => {
    let tags = p.data.tags.map(s => s.toLowerCase());
    return tags.includes(tag);
  });
  return result;
});
```

When you select a tag, it opens a page for that specific tag.
This uses the same pagination feature as the blog page:

{% raw %}
```jinja
---
layout: base.njk
pagination:
  data: collections.tags
  size: 1
  alias: tag
permalink: "/tags/{{ tag | slugify }}/index.html"
---

<article>
  <h2>Posts with tag: {{tag}}</h2>
  {% set posts = collections.post | filterByTag(tag) %}
  <ul class="post-list">
  {% for post in posts %}
  {% include "post-preview.njk" %}
  {% endfor %}
  </ul>
</article>
```
{% endraw %}

You'll notice I include a file in the template.
This is because I preview posts in quite a few places, so I moved it all to the following template file:

{% raw %}
```jinja
<li class="post-header">
  <h2 class="post-title"><a href="{{post.url}}">{{ post.data.title }}</a></h2>
  <div class="time-tags">
    <time>{% formatdatefull page.date %}</time>
  </div>
  <p class="post-excerpt">
    {{post.page.excerpt | md | safe}}
    &nbsp;
    <a class="continue-reading" href="{{post.url}}">Continue reading &rarr;</a>
  </p>
  {% if post.data.tags | length > 1 %}
  <p class="post-tags">
    tags: [
    {% for tag in post.data.tags %}
    {% if tag != "post" %}
    <a class="underline" href="/tags/{{ tag | slugify }}/index.html">{{ tag }}</a>{{ "," if loop.last == false }}
    {% endif %}
    {% endfor %}
    ]
  </p>
  {% endif %}
</li>
```
{% endraw %}

The `formatdatefull` is another custom shortcode I wrote to format the date into something acceptable.
Here's what it looks like:

```js
eleventyConfig.addShortcode("formatdatefull", (date) => {
  if (!date) return "";

  let day = date.getUTCDate();
  let day_string = day.toString();

  let mod = day % 10;
  if (day == 11 || day == 12 || day == 13) {
    day_string = day_string + "th";
  } else if (mod == 1) {
    day_string = day_string + "st";
  } else if (mod == 2) {
    day_string = day_string + "nd";
  } else if (mod == 3) { 
    day_string = day_string + "rd";
  } else {
    day_string = day_string + "th";
  }

  let month_string = months[date.getUTCMonth()];
  let year_string = date.getUTCFullYear().toString();

  return month_string + " " + day_string + ", " + year_string;
});
```

I probably should've used a library for this, but I felt this was simple enough that I could roll my own function.
Plus, I only ever need this format, so it's fine. I'll re-evaluate if I plan on translating this blog to other languages.

The `excerpt` property is a property of a page that contains an excerpt.
It's pretty self explanatory!
However, the default value for it sucks.
You can customize it by adding a delimiter to your post to define where you want your excerpt to end, but I don't want to have to specify that manually.
I only need the first paragraph to be shown, so I changed the parsing options for frontmatter (the library Eleventy uses for parsing the YAML headers):

```js
eleventyConfig.setFrontMatterParsingOptions({
  excerpt: (file, options) => {
    // Return the first paragraph
    file.excerpt = file.content.split('\n\n').slice(0, 1).join(' ');
  },
})
```

In markdown, paragraphs are separated by two newlines, so I split the files every time there's two newlines in a row, get the very first paragraph from that and join it into a string.
Feel free to criticize my JavaScript.
This only ever runs on my machine when I build the site, so I don't care all that much about performance.
Maybe it'll actually become an issue when I have many blog posts, but this is a problem for later me.

The post-preview template also uses a custom filter.
Filters are for modifying text in a template before outputting it.
The filter in question is the `md` filter which I pass the excerpt to.

Here's what it looks like:

```js
// at the top of the file
import markdownIt from "markdown-it";

// ...

eleventyConfig.addFilter("md", (content) => {
  return markdownIt({ html: true }).render(content);
})
```

I basically just render the markdown using markdownIt (the library Eleventy uses for rendering markdown) before sending it back.
If I don't do this then markdown links are not turned into anchors properly and it's all very very bad.

I also added footnotes and syntax highlighting for code blocks to my blog using markdown-it-footnote and highlight.js respectively:

```sh
$ npm install highlight.js
$ npm install markdown-it-footnote
```

```js
import markdownItFootnote from "markdown-it-footnote";
import hljs from "highlight.js";

// ...

const markdownLibrary = markdownIt({
  html: true,
  breaks: false,
  linkify: true,
  typographer: true,

  highlight: function(str, lang) {
    if (lang && hljs.getLanguage(lang)) {
      try {
        return hljs.highlight(str, { language: lang }).value;
      } catch(__) {}
    }
  }
}).use(markdownItFootnote);
eleventyConfig.setLibrary("md", markdownLibrary);
```

For the highlighting I then had to manually input all the colors for each token in my style.css file.^[This took me a while, because even after I thought I was done, I found many broken highlights while writing this post.]
This took me a bit and there are existing color schemes online, but I wanted to use my favorite colorscheme kanagawa-dragon, and I couldn't find it.

I then set up an about me page. There's nothing interesting about that page so I'll skip over it, it's just plain HTML.

Finally, I added an atom feed.^[I know the link in my header says rss even though it's an Atom feed. I was going to have it say "feed", but it didn't fit neatly under the "loudbytes" text, so I changed it to rss. Feel free to contact me to complain.]
Eleventy supports this with a plugin.
I only needed to install plugin and add the following code to my config:

```sh
$ npm install @11ty/eleventy-plugin-rss
```

```js
import { feedPlugin } from "@11ty/eleventy-plugin-rss";

// ...

eleventyConfig.addPlugin(feedPlugin, {
  type: "atom",
  outputPath: "/feed.xml",
  collection: {
    name: "post",
    limit: 10,
  },
  metadata: {
    language: "en",
    title: "loudbytes",
    subtitle: "Posts about programming and video games",
    base: "https://loudbytes.dev/",
    author: {
      name: "Antoine Gallien",
    }
  }
});
```

And voila! We have a working feed.

All and all, if I were to rate my experience with Eleventy, I'd give it a 9 out of 10.
Having to specify the files to copy over is annoying when I set the source directory.
I would have liked for  it to automatically copy over everything, or at least for there to be a setting.
Otherwise though I enjoyed Eleventy, everytime I wanted to do something it was very intuitive.
The worst part of making this was easily dealing with CSS !
 
